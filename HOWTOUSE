Just copy gf.c and gf.h to your program directory.

Include gf.h
        #include "gf.h"

and initialize (call before all GF16 arithmetic functions)
	GF16init();
	
For multiplication c = a * b, use
	uint16_t a, b, c;
	c = GF16mul(a, b);
	
For division c = a / b, use
	uint16_t a, b, c;
	c = GF16div(a, b);

For repeated (regional) computation like:
	uint16_t a, x[];
	for (i = 0; i < N; i++) {
		b = GFmul(a, x[i]);
	}

where 'a' is static and 'x' is an array, you can speed up by a region
computation technique.

Change the above code to:
	uint16_t a, x[], *gf_a, *_x;
	gf_a = GF16memL + GF16memIdx[a];
	_x = x;
	for (i = 0; i < N; i++) {
		b = gf_a[GF16memIdx[*_x]];
		_x++;
	}

For division:
	uint16_t a, x[];
	for (i = 0; i < N; i++) {
		b = GFdiv(a, x[i]);
	}

use
	uint16_t a, x[], *gf_a, *_x;
	gf_a = GF16memH + GF16memIdx[a];
	_x = x;
	for (i = 0; i < N; i++) {
		b = *(gf_a - GF16memIdx[*_x]);
		_x++;
	}

For another division such as:
	uint16_t a, x[];
	for (i = 0; i < N; i++) {
		b = GFdiv(x[i], a);
	}

do
	uint16_t a, x[], *gf_a, *_x;
	gf_a = GF16memH - GF16memIdx[a];
	_x = x;
	for (i = 0; i < N; i++) {
		b = gf_a[GF16memIdx[*_x]];
		_x++;
	}

For more speedup in region calculation, try GF16crtRegTbl() and
GF16crtSpltRegTbl().
Especially, the technique using GF16crtSpltRegTbl() requires only 1kB memory
and will fit L1 cache.

GF16crtRegTbl() technique:
    Create table for regional calculation such as:
        a * x[i]
        a / x[i]
        x[i] / a
    This method may fit L2 cache and will be fast.

    For a * x[i],
        uint16_t *gf_a = GF16crtRegTbl(a, 0);
        for (i = 0; i < N; i++) {
            y[i] = gf_a[x[i]]; // This is equal to GFmul(a, x[i]);
            // Or use y[i] = GF16RT(gf_a, x[i]);
        }
        free(gf_a);

    For a / x[i],
        uint16_t *gf_a = GF16crtRegTbl(a, 1);
        for (i = 0; i < N; i++) {
            y[i] = gf_a[x[i]]; // This is equal to GFdiv(a, x[i]);
            // Or use y[i] = GF16RT(gf_a, x[i]);
        }
        free(gf_a);

    For x[i] / a,
        uint16_t *gf_a = GF16crtRegTbl(a, 2);
        for (i = 0; i < N; i++) {
            y[i] = gf_a[x[i]]; // This is equal to GFdiv(x[i], a);
            // Or use y[i] = GF16RT(gf_a, x[i]);
        }
        free(gf_a);

GF16crtSpltRegTbl technique:
    Create 8bit split tables for regional calculation such as:
        a * x[i]
        a / x[i]
        x[i] / a
    This method may fit L1 cache and will be even faster.

    For a * x[i],
        uint16_t *gf_a_l = GF16crtSpltRegTbl(a, 0);
        uint16_t *gf_a_h = gf_a_l + 256;
        uint16_t xi;
        for (i = 0; i < N; i++) {
            xi = x[i];
            y[i] = gf_a_h[xi >> 8] ^ gf_a_l[xi & 0xff]; // = GFmul(a, x[i]);
            // Or use y[i] = GF16SRT(gf_a_l, gf_a_h, xi);
        }
        free(gf_a_l);

    For a / x[i],
        uint16_t *gf_a_l = GF16crtSpltRegTbl(a, 1);
        uint16_t *gf_a_h = gf_a_l + 256;
        uint16_t xi;
        for (i = 0; i < N; i++) {
            xi = x[i];
            y[i] = gf_a_h[xi >> 8] ^ gf_a_l[xi & 0xff]; // = GFdiv(a, x[i]);
            // Or use y[i] = GF16SRT(gf_a_l, gf_a_h, xi);
        }
        free(gf_a_l);

    For x[i] / a,
        uint16_t *gf_a_l = GF16crtSpltRegTbl(a, 1);
        uint16_t *gf_a_h = gf_a_l + 256;
        uint16_t xi;
        for (i = 0; i < N; i++) {
            xi = x[i];
            y[i] = gf_a_h[xi >> 8] ^ gf_a_l[xi & 0xff]; // = GFdiv(x[i], a);
            // Or use y[i] = GF16SRT(gf_a_l, gf_a_h, xi);
        }
        free(gf_a_l);

See also gf-bench/*/gf-nishida-region-16/gf-bench.c.
